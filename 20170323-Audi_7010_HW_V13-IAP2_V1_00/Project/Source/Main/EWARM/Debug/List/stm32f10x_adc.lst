###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Jun/2016  13:18:46 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm #
#                    32f10x_adc.c                                             #
#    Command line =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm #
#                    32f10x_adc.c -D USE_STDPERIPH_DRIVER -D                  #
#                    USE_STM32100B_EVAL -D STM32F10X_CL -lc                   #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\ -lA F:\软件工程\平台正式代码001\Benze_MainBoa #
#                    rd\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_T #
#                    emplate\EWARM\Debug\List\ -o                             #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_F #
#                    ull.h" -I F:\软件工程\平台正式代码001\Benze_MainBoard\ba #
#                    oma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Templa #
#                    te\EWARM\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\ -I F:\软件工程\平台正式代码001\Benze_Mai #
#                    nBoard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeri #
#                    ph_Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph #
#                    _Driver\inc\ -I F:\软件工程\平台正式代码001\Benze_MainBo #
#                    ard\baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_ #
#                    Template\EWARM\..\..\..\Libraries\STM32F10x_StdPeriph_Dr #
#                    iver\src\ -I F:\软件工程\平台正式代码001\Benze_MainBoard #
#                    \baoma_36\benci_newC_V45\Project\STM32F10x_StdPeriph_Tem #
#                    plate\EWARM\..\..\..\Project/Common\ -I                  #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/TW8836\ -I F:\软件工程\平台正式代码001\B #
#                    enze_MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x #
#                    _StdPeriph_Template\EWARM\..\..\..\Project/CAN\ -I       #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Project/FM\ -I F:\软件工程\平台正式代码001\Benze #
#                    _MainBoard\baoma_36\benci_newC_V45\Project\STM32F10x_Std #
#                    Periph_Template\EWARM\..\..\..\Project/ARM\ -I           #
#                    F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\. #
#                    .\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\  #
#                    -On -I "C:\Program Files\IAR Systems\Embedded Workbench  #
#                    6.0_2\arm\CMSIS\Include\"                                #
#    List file    =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\List\stm32f10x_adc.lst                              #
#    Object file  =  F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\ben #
#                    ci_newC_V45\Project\STM32F10x_StdPeriph_Template\EWARM\D #
#                    ebug\Obj\stm32f10x_adc.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\软件工程\平台正式代码001\Benze_MainBoard\baoma_36\benci_newC_V45\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_adc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the ADC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_adc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup ADC
     31            * @brief ADC driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup ADC_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup ADC_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ADC DISCNUM mask */
     48          #define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
     49          
     50          /* ADC DISCEN mask */
     51          #define CR1_DISCEN_Set              ((uint32_t)0x00000800)
     52          #define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
     53          
     54          /* ADC JAUTO mask */
     55          #define CR1_JAUTO_Set               ((uint32_t)0x00000400)
     56          #define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
     57          
     58          /* ADC JDISCEN mask */
     59          #define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
     60          #define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
     61          
     62          /* ADC AWDCH mask */
     63          #define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
     64          
     65          /* ADC Analog watchdog enable mode mask */
     66          #define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
     67          
     68          /* CR1 register Mask */
     69          #define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
     70          
     71          /* ADC ADON mask */
     72          #define CR2_ADON_Set                ((uint32_t)0x00000001)
     73          #define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
     74          
     75          /* ADC DMA mask */
     76          #define CR2_DMA_Set                 ((uint32_t)0x00000100)
     77          #define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
     78          
     79          /* ADC RSTCAL mask */
     80          #define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
     81          
     82          /* ADC CAL mask */
     83          #define CR2_CAL_Set                 ((uint32_t)0x00000004)
     84          
     85          /* ADC SWSTART mask */
     86          #define CR2_SWSTART_Set             ((uint32_t)0x00400000)
     87          
     88          /* ADC EXTTRIG mask */
     89          #define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
     90          #define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
     91          
     92          /* ADC Software start mask */
     93          #define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
     94          #define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
     95          
     96          /* ADC JEXTSEL mask */
     97          #define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
     98          
     99          /* ADC JEXTTRIG mask */
    100          #define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
    101          #define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
    102          
    103          /* ADC JSWSTART mask */
    104          #define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
    105          
    106          /* ADC injected software start mask */
    107          #define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
    108          #define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
    109          
    110          /* ADC TSPD mask */
    111          #define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
    112          #define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
    113          
    114          /* CR2 register Mask */
    115          #define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
    116          
    117          /* ADC SQx mask */
    118          #define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
    119          #define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
    120          #define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
    121          
    122          /* SQR1 register Mask */
    123          #define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
    124          
    125          /* ADC JSQx mask */
    126          #define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
    127          
    128          /* ADC JL mask */
    129          #define JSQR_JL_Set                 ((uint32_t)0x00300000)
    130          #define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
    131          
    132          /* ADC SMPx mask */
    133          #define SMPR1_SMP_Set               ((uint32_t)0x00000007)
    134          #define SMPR2_SMP_Set               ((uint32_t)0x00000007)
    135          
    136          /* ADC JDRx registers offset */
    137          #define JDR_Offset                  ((uint8_t)0x28)
    138          
    139          /* ADC1 DR register base address */
    140          #define DR_ADDRESS                  ((uint32_t)0x4001244C)
    141          
    142          /**
    143            * @}
    144            */
    145          
    146          /** @defgroup ADC_Private_Macros
    147            * @{
    148            */
    149          
    150          /**
    151            * @}
    152            */
    153          
    154          /** @defgroup ADC_Private_Variables
    155            * @{
    156            */
    157          
    158          /**
    159            * @}
    160            */
    161          
    162          /** @defgroup ADC_Private_FunctionPrototypes
    163            * @{
    164            */
    165          
    166          /**
    167            * @}
    168            */
    169          
    170          /** @defgroup ADC_Private_Functions
    171            * @{
    172            */
    173          
    174          /**
    175            * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
    176            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    177            * @retval None
    178            */
    179          void ADC_DeInit(ADC_TypeDef *ADCx)
    180          {
    181              /* Check the parameters */
    182              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    183          
    184              if (ADCx == ADC1)
    185              {
    186                  /* Enable ADC1 reset state */
    187                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
    188                  /* Release ADC1 from reset state */
    189                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
    190              }
    191              else if (ADCx == ADC2)
    192              {
    193                  /* Enable ADC2 reset state */
    194                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
    195                  /* Release ADC2 from reset state */
    196                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
    197              }
    198              else
    199              {
    200                  if (ADCx == ADC3)
    201                  {
    202                      /* Enable ADC3 reset state */
    203                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
    204                      /* Release ADC3 from reset state */
    205                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
    206                  }
    207              }
    208          }
    209          
    210          /**
    211            * @brief  Initializes the ADCx peripheral according to the specified parameters
    212            *         in the ADC_InitStruct.
    213            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    214            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    215            *         the configuration information for the specified ADC peripheral.
    216            * @retval None
    217            */
    218          void ADC_Init(ADC_TypeDef *ADCx, ADC_InitTypeDef *ADC_InitStruct)
    219          {
    220              uint32_t tmpreg1 = 0;
    221              uint8_t tmpreg2 = 0;
    222              /* Check the parameters */
    223              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    224              assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    225              assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    226              assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
    227              assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));
    228              assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
    229              assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    230          
    231              /*---------------------------- ADCx CR1 Configuration -----------------*/
    232              /* Get the ADCx CR1 value */
    233              tmpreg1 = ADCx->CR1;
    234              /* Clear DUALMOD and SCAN bits */
    235              tmpreg1 &= CR1_CLEAR_Mask;
    236              /* Configure ADCx: Dual mode and scan conversion mode */
    237              /* Set DUALMOD bits according to ADC_Mode value */
    238              /* Set SCAN bit according to ADC_ScanConvMode value */
    239              tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
    240              /* Write to ADCx CR1 */
    241              ADCx->CR1 = tmpreg1;
    242          
    243              /*---------------------------- ADCx CR2 Configuration -----------------*/
    244              /* Get the ADCx CR2 value */
    245              tmpreg1 = ADCx->CR2;
    246              /* Clear CONT, ALIGN and EXTSEL bits */
    247              tmpreg1 &= CR2_CLEAR_Mask;
    248              /* Configure ADCx: external trigger event and continuous conversion mode */
    249              /* Set ALIGN bit according to ADC_DataAlign value */
    250              /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    251              /* Set CONT bit according to ADC_ContinuousConvMode value */
    252              tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
    253                                    ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    254              /* Write to ADCx CR2 */
    255              ADCx->CR2 = tmpreg1;
    256          
    257              /*---------------------------- ADCx SQR1 Configuration -----------------*/
    258              /* Get the ADCx SQR1 value */
    259              tmpreg1 = ADCx->SQR1;
    260              /* Clear L bits */
    261              tmpreg1 &= SQR1_CLEAR_Mask;
    262              /* Configure ADCx: regular channel sequence length */
    263              /* Set L bits according to ADC_NbrOfChannel value */
    264              tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
    265              tmpreg1 |= (uint32_t)tmpreg2 << 20;
    266              /* Write to ADCx SQR1 */
    267              ADCx->SQR1 = tmpreg1;
    268          }
    269          
    270          /**
    271            * @brief  Fills each ADC_InitStruct member with its default value.
    272            * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
    273            * @retval None
    274            */
    275          void ADC_StructInit(ADC_InitTypeDef *ADC_InitStruct)
    276          {
    277              /* Reset ADC init structure parameters values */
    278              /* Initialize the ADC_Mode member */
    279              ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
    280              /* initialize the ADC_ScanConvMode member */
    281              ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    282              /* Initialize the ADC_ContinuousConvMode member */
    283              ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    284              /* Initialize the ADC_ExternalTrigConv member */
    285              ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    286              /* Initialize the ADC_DataAlign member */
    287              ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    288              /* Initialize the ADC_NbrOfChannel member */
    289              ADC_InitStruct->ADC_NbrOfChannel = 1;
    290          }
    291          
    292          /**
    293            * @brief  Enables or disables the specified ADC peripheral.
    294            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    295            * @param  NewState: new state of the ADCx peripheral.
    296            *   This parameter can be: ENABLE or DISABLE.
    297            * @retval None
    298            */
    299          void ADC_Cmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    300          {
    301              /* Check the parameters */
    302              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    303              assert_param(IS_FUNCTIONAL_STATE(NewState));
    304              if (NewState != DISABLE)
    305              {
    306                  /* Set the ADON bit to wake up the ADC from power down mode */
    307                  ADCx->CR2 |= CR2_ADON_Set;
    308              }
    309              else
    310              {
    311                  /* Disable the selected ADC peripheral */
    312                  ADCx->CR2 &= CR2_ADON_Reset;
    313              }
    314          }
    315          
    316          /**
    317            * @brief  Enables or disables the specified ADC DMA request.
    318            * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
    319            *   Note: ADC2 hasn't a DMA capability.
    320            * @param  NewState: new state of the selected ADC DMA transfer.
    321            *   This parameter can be: ENABLE or DISABLE.
    322            * @retval None
    323            */
    324          void ADC_DMACmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    325          {
    326              /* Check the parameters */
    327              assert_param(IS_ADC_DMA_PERIPH(ADCx));
    328              assert_param(IS_FUNCTIONAL_STATE(NewState));
    329              if (NewState != DISABLE)
    330              {
    331                  /* Enable the selected ADC DMA request */
    332                  ADCx->CR2 |= CR2_DMA_Set;
    333              }
    334              else
    335              {
    336                  /* Disable the selected ADC DMA request */
    337                  ADCx->CR2 &= CR2_DMA_Reset;
    338              }
    339          }
    340          
    341          /**
    342            * @brief  Enables or disables the specified ADC interrupts.
    343            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    344            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.
    345            *   This parameter can be any combination of the following values:
    346            *     @arg ADC_IT_EOC: End of conversion interrupt mask
    347            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
    348            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
    349            * @param  NewState: new state of the specified ADC interrupts.
    350            *   This parameter can be: ENABLE or DISABLE.
    351            * @retval None
    352            */
    353          void ADC_ITConfig(ADC_TypeDef *ADCx, uint16_t ADC_IT, FunctionalState NewState)
    354          {
    355              uint8_t itmask = 0;
    356              /* Check the parameters */
    357              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    358              assert_param(IS_FUNCTIONAL_STATE(NewState));
    359              assert_param(IS_ADC_IT(ADC_IT));
    360              /* Get the ADC IT index */
    361              itmask = (uint8_t)ADC_IT;
    362              if (NewState != DISABLE)
    363              {
    364                  /* Enable the selected ADC interrupts */
    365                  ADCx->CR1 |= itmask;
    366              }
    367              else
    368              {
    369                  /* Disable the selected ADC interrupts */
    370                  ADCx->CR1 &= (~(uint32_t)itmask);
    371              }
    372          }
    373          
    374          /**
    375            * @brief  Resets the selected ADC calibration registers.
    376            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    377            * @retval None
    378            */
    379          void ADC_ResetCalibration(ADC_TypeDef *ADCx)
    380          {
    381              /* Check the parameters */
    382              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    383              /* Resets the selected ADC calibration registers */
    384              ADCx->CR2 |= CR2_RSTCAL_Set;
    385          }
    386          
    387          /**
    388            * @brief  Gets the selected ADC reset calibration registers status.
    389            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    390            * @retval The new state of ADC reset calibration registers (SET or RESET).
    391            */
    392          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef *ADCx)
    393          {
    394              FlagStatus bitstatus = RESET;
    395              /* Check the parameters */
    396              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    397              /* Check the status of RSTCAL bit */
    398              if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
    399              {
    400                  /* RSTCAL bit is set */
    401                  bitstatus = SET;
    402              }
    403              else
    404              {
    405                  /* RSTCAL bit is reset */
    406                  bitstatus = RESET;
    407              }
    408              /* Return the RSTCAL bit status */
    409              return  bitstatus;
    410          }
    411          
    412          /**
    413            * @brief  Starts the selected ADC calibration process.
    414            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    415            * @retval None
    416            */
    417          void ADC_StartCalibration(ADC_TypeDef *ADCx)
    418          {
    419              /* Check the parameters */
    420              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    421              /* Enable the selected ADC calibration process */
    422              ADCx->CR2 |= CR2_CAL_Set;
    423          }
    424          
    425          /**
    426            * @brief  Gets the selected ADC calibration status.
    427            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    428            * @retval The new state of ADC calibration (SET or RESET).
    429            */
    430          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef *ADCx)
    431          {
    432              FlagStatus bitstatus = RESET;
    433              /* Check the parameters */
    434              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    435              /* Check the status of CAL bit */
    436              if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
    437              {
    438                  /* CAL bit is set: calibration on going */
    439                  bitstatus = SET;
    440              }
    441              else
    442              {
    443                  /* CAL bit is reset: end of calibration */
    444                  bitstatus = RESET;
    445              }
    446              /* Return the CAL bit status */
    447              return  bitstatus;
    448          }
    449          
    450          /**
    451            * @brief  Enables or disables the selected ADC software start conversion .
    452            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    453            * @param  NewState: new state of the selected ADC software start conversion.
    454            *   This parameter can be: ENABLE or DISABLE.
    455            * @retval None
    456            */
    457          void ADC_SoftwareStartConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    458          {
    459              /* Check the parameters */
    460              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    461              assert_param(IS_FUNCTIONAL_STATE(NewState));
    462              if (NewState != DISABLE)
    463              {
    464                  /* Enable the selected ADC conversion on external event and start the selected
    465                     ADC conversion */
    466                  ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
    467              }
    468              else
    469              {
    470                  /* Disable the selected ADC conversion on external event and stop the selected
    471                     ADC conversion */
    472                  ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
    473              }
    474          }
    475          
    476          /**
    477            * @brief  Gets the selected ADC Software start conversion Status.
    478            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    479            * @retval The new state of ADC software start conversion (SET or RESET).
    480            */
    481          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef *ADCx)
    482          {
    483              FlagStatus bitstatus = RESET;
    484              /* Check the parameters */
    485              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    486              /* Check the status of SWSTART bit */
    487              if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
    488              {
    489                  /* SWSTART bit is set */
    490                  bitstatus = SET;
    491              }
    492              else
    493              {
    494                  /* SWSTART bit is reset */
    495                  bitstatus = RESET;
    496              }
    497              /* Return the SWSTART bit status */
    498              return  bitstatus;
    499          }
    500          
    501          /**
    502            * @brief  Configures the discontinuous mode for the selected ADC regular
    503            *         group channel.
    504            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    505            * @param  Number: specifies the discontinuous mode regular channel
    506            *         count value. This number must be between 1 and 8.
    507            * @retval None
    508            */
    509          void ADC_DiscModeChannelCountConfig(ADC_TypeDef *ADCx, uint8_t Number)
    510          {
    511              uint32_t tmpreg1 = 0;
    512              uint32_t tmpreg2 = 0;
    513              /* Check the parameters */
    514              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    515              assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    516              /* Get the old register value */
    517              tmpreg1 = ADCx->CR1;
    518              /* Clear the old discontinuous mode channel count */
    519              tmpreg1 &= CR1_DISCNUM_Reset;
    520              /* Set the discontinuous mode channel count */
    521              tmpreg2 = Number - 1;
    522              tmpreg1 |= tmpreg2 << 13;
    523              /* Store the new register value */
    524              ADCx->CR1 = tmpreg1;
    525          }
    526          
    527          /**
    528            * @brief  Enables or disables the discontinuous mode on regular group
    529            *         channel for the specified ADC
    530            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    531            * @param  NewState: new state of the selected ADC discontinuous mode
    532            *         on regular group channel.
    533            *         This parameter can be: ENABLE or DISABLE.
    534            * @retval None
    535            */
    536          void ADC_DiscModeCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    537          {
    538              /* Check the parameters */
    539              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    540              assert_param(IS_FUNCTIONAL_STATE(NewState));
    541              if (NewState != DISABLE)
    542              {
    543                  /* Enable the selected ADC regular discontinuous mode */
    544                  ADCx->CR1 |= CR1_DISCEN_Set;
    545              }
    546              else
    547              {
    548                  /* Disable the selected ADC regular discontinuous mode */
    549                  ADCx->CR1 &= CR1_DISCEN_Reset;
    550              }
    551          }
    552          
    553          /**
    554            * @brief  Configures for the selected ADC regular channel its corresponding
    555            *         rank in the sequencer and its sample time.
    556            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    557            * @param  ADC_Channel: the ADC channel to configure.
    558            *   This parameter can be one of the following values:
    559            *     @arg ADC_Channel_0: ADC Channel0 selected
    560            *     @arg ADC_Channel_1: ADC Channel1 selected
    561            *     @arg ADC_Channel_2: ADC Channel2 selected
    562            *     @arg ADC_Channel_3: ADC Channel3 selected
    563            *     @arg ADC_Channel_4: ADC Channel4 selected
    564            *     @arg ADC_Channel_5: ADC Channel5 selected
    565            *     @arg ADC_Channel_6: ADC Channel6 selected
    566            *     @arg ADC_Channel_7: ADC Channel7 selected
    567            *     @arg ADC_Channel_8: ADC Channel8 selected
    568            *     @arg ADC_Channel_9: ADC Channel9 selected
    569            *     @arg ADC_Channel_10: ADC Channel10 selected
    570            *     @arg ADC_Channel_11: ADC Channel11 selected
    571            *     @arg ADC_Channel_12: ADC Channel12 selected
    572            *     @arg ADC_Channel_13: ADC Channel13 selected
    573            *     @arg ADC_Channel_14: ADC Channel14 selected
    574            *     @arg ADC_Channel_15: ADC Channel15 selected
    575            *     @arg ADC_Channel_16: ADC Channel16 selected
    576            *     @arg ADC_Channel_17: ADC Channel17 selected
    577            * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
    578            * @param  ADC_SampleTime: The sample time value to be set for the selected channel.
    579            *   This parameter can be one of the following values:
    580            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    581            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    582            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    583            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles
    584            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles
    585            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles
    586            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles
    587            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles
    588            * @retval None
    589            */
    590          void ADC_RegularChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    591          {
    592              uint32_t tmpreg1 = 0, tmpreg2 = 0;
    593              /* Check the parameters */
    594              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    595              assert_param(IS_ADC_CHANNEL(ADC_Channel));
    596              assert_param(IS_ADC_REGULAR_RANK(Rank));
    597              assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    598              /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    599              if (ADC_Channel > ADC_Channel_9)
    600              {
    601                  /* Get the old register value */
    602                  tmpreg1 = ADCx->SMPR1;
    603                  /* Calculate the mask to clear */
    604                  tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    605                  /* Clear the old channel sample time */
    606                  tmpreg1 &= ~tmpreg2;
    607                  /* Calculate the mask to set */
    608                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    609                  /* Set the new channel sample time */
    610                  tmpreg1 |= tmpreg2;
    611                  /* Store the new register value */
    612                  ADCx->SMPR1 = tmpreg1;
    613              }
    614              else /* ADC_Channel include in ADC_Channel_[0..9] */
    615              {
    616                  /* Get the old register value */
    617                  tmpreg1 = ADCx->SMPR2;
    618                  /* Calculate the mask to clear */
    619                  tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    620                  /* Clear the old channel sample time */
    621                  tmpreg1 &= ~tmpreg2;
    622                  /* Calculate the mask to set */
    623                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    624                  /* Set the new channel sample time */
    625                  tmpreg1 |= tmpreg2;
    626                  /* Store the new register value */
    627                  ADCx->SMPR2 = tmpreg1;
    628              }
    629              /* For Rank 1 to 6 */
    630              if (Rank < 7)
    631              {
    632                  /* Get the old register value */
    633                  tmpreg1 = ADCx->SQR3;
    634                  /* Calculate the mask to clear */
    635                  tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    636                  /* Clear the old SQx bits for the selected rank */
    637                  tmpreg1 &= ~tmpreg2;
    638                  /* Calculate the mask to set */
    639                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    640                  /* Set the SQx bits for the selected rank */
    641                  tmpreg1 |= tmpreg2;
    642                  /* Store the new register value */
    643                  ADCx->SQR3 = tmpreg1;
    644              }
    645              /* For Rank 7 to 12 */
    646              else if (Rank < 13)
    647              {
    648                  /* Get the old register value */
    649                  tmpreg1 = ADCx->SQR2;
    650                  /* Calculate the mask to clear */
    651                  tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    652                  /* Clear the old SQx bits for the selected rank */
    653                  tmpreg1 &= ~tmpreg2;
    654                  /* Calculate the mask to set */
    655                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    656                  /* Set the SQx bits for the selected rank */
    657                  tmpreg1 |= tmpreg2;
    658                  /* Store the new register value */
    659                  ADCx->SQR2 = tmpreg1;
    660              }
    661              /* For Rank 13 to 16 */
    662              else
    663              {
    664                  /* Get the old register value */
    665                  tmpreg1 = ADCx->SQR1;
    666                  /* Calculate the mask to clear */
    667                  tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    668                  /* Clear the old SQx bits for the selected rank */
    669                  tmpreg1 &= ~tmpreg2;
    670                  /* Calculate the mask to set */
    671                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    672                  /* Set the SQx bits for the selected rank */
    673                  tmpreg1 |= tmpreg2;
    674                  /* Store the new register value */
    675                  ADCx->SQR1 = tmpreg1;
    676              }
    677          }
    678          
    679          /**
    680            * @brief  Enables or disables the ADCx conversion through external trigger.
    681            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    682            * @param  NewState: new state of the selected ADC external trigger start of conversion.
    683            *   This parameter can be: ENABLE or DISABLE.
    684            * @retval None
    685            */
    686          void ADC_ExternalTrigConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    687          {
    688              /* Check the parameters */
    689              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    690              assert_param(IS_FUNCTIONAL_STATE(NewState));
    691              if (NewState != DISABLE)
    692              {
    693                  /* Enable the selected ADC conversion on external event */
    694                  ADCx->CR2 |= CR2_EXTTRIG_Set;
    695              }
    696              else
    697              {
    698                  /* Disable the selected ADC conversion on external event */
    699                  ADCx->CR2 &= CR2_EXTTRIG_Reset;
    700              }
    701          }
    702          
    703          /**
    704            * @brief  Returns the last ADCx conversion result data for regular channel.
    705            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    706            * @retval The Data conversion value.
    707            */
    708          uint16_t ADC_GetConversionValue(ADC_TypeDef *ADCx)
    709          {
    710              /* Check the parameters */
    711              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    712              /* Return the selected ADC conversion value */
    713              return (uint16_t) ADCx->DR;
    714          }
    715          
    716          /**
    717            * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
    718            * @retval The Data conversion value.
    719            */
    720          uint32_t ADC_GetDualModeConversionValue(void)
    721          {
    722              /* Return the dual mode conversion value */
    723              return (*(__IO uint32_t *) DR_ADDRESS);
    724          }
    725          
    726          /**
    727            * @brief  Enables or disables the selected ADC automatic injected group
    728            *         conversion after regular one.
    729            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    730            * @param  NewState: new state of the selected ADC auto injected conversion
    731            *   This parameter can be: ENABLE or DISABLE.
    732            * @retval None
    733            */
    734          void ADC_AutoInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    735          {
    736              /* Check the parameters */
    737              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    738              assert_param(IS_FUNCTIONAL_STATE(NewState));
    739              if (NewState != DISABLE)
    740              {
    741                  /* Enable the selected ADC automatic injected group conversion */
    742                  ADCx->CR1 |= CR1_JAUTO_Set;
    743              }
    744              else
    745              {
    746                  /* Disable the selected ADC automatic injected group conversion */
    747                  ADCx->CR1 &= CR1_JAUTO_Reset;
    748              }
    749          }
    750          
    751          /**
    752            * @brief  Enables or disables the discontinuous mode for injected group
    753            *         channel for the specified ADC
    754            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    755            * @param  NewState: new state of the selected ADC discontinuous mode
    756            *         on injected group channel.
    757            *   This parameter can be: ENABLE or DISABLE.
    758            * @retval None
    759            */
    760          void ADC_InjectedDiscModeCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    761          {
    762              /* Check the parameters */
    763              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    764              assert_param(IS_FUNCTIONAL_STATE(NewState));
    765              if (NewState != DISABLE)
    766              {
    767                  /* Enable the selected ADC injected discontinuous mode */
    768                  ADCx->CR1 |= CR1_JDISCEN_Set;
    769              }
    770              else
    771              {
    772                  /* Disable the selected ADC injected discontinuous mode */
    773                  ADCx->CR1 &= CR1_JDISCEN_Reset;
    774              }
    775          }
    776          
    777          /**
    778            * @brief  Configures the ADCx external trigger for injected channels conversion.
    779            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    780            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
    781            *   This parameter can be one of the following values:
    782            *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
    783            *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
    784            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
    785            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
    786            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
    787            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
    788            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
    789            *                                                       capture compare4 event selected (for ADC1 and ADC2)
    790            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
    791            *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)
    792            *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
    793            *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)
    794            *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)
    795            *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
    796            *                                          by external trigger (for ADC1, ADC2 and ADC3)
    797            * @retval None
    798            */
    799          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef *ADCx, uint32_t ADC_ExternalTrigInjecConv)
    800          {
    801              uint32_t tmpreg = 0;
    802              /* Check the parameters */
    803              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    804              assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
    805              /* Get the old register value */
    806              tmpreg = ADCx->CR2;
    807              /* Clear the old external event selection for injected group */
    808              tmpreg &= CR2_JEXTSEL_Reset;
    809              /* Set the external event selection for injected group */
    810              tmpreg |= ADC_ExternalTrigInjecConv;
    811              /* Store the new register value */
    812              ADCx->CR2 = tmpreg;
    813          }
    814          
    815          /**
    816            * @brief  Enables or disables the ADCx injected channels conversion through
    817            *         external trigger
    818            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    819            * @param  NewState: new state of the selected ADC external trigger start of
    820            *         injected conversion.
    821            *   This parameter can be: ENABLE or DISABLE.
    822            * @retval None
    823            */
    824          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    825          {
    826              /* Check the parameters */
    827              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    828              assert_param(IS_FUNCTIONAL_STATE(NewState));
    829              if (NewState != DISABLE)
    830              {
    831                  /* Enable the selected ADC external event selection for injected group */
    832                  ADCx->CR2 |= CR2_JEXTTRIG_Set;
    833              }
    834              else
    835              {
    836                  /* Disable the selected ADC external event selection for injected group */
    837                  ADCx->CR2 &= CR2_JEXTTRIG_Reset;
    838              }
    839          }
    840          
    841          /**
    842            * @brief  Enables or disables the selected ADC start of the injected
    843            *         channels conversion.
    844            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    845            * @param  NewState: new state of the selected ADC software start injected conversion.
    846            *   This parameter can be: ENABLE or DISABLE.
    847            * @retval None
    848            */
    849          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState)
    850          {
    851              /* Check the parameters */
    852              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    853              assert_param(IS_FUNCTIONAL_STATE(NewState));
    854              if (NewState != DISABLE)
    855              {
    856                  /* Enable the selected ADC conversion for injected group on external event and start the selected
    857                     ADC injected conversion */
    858                  ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
    859              }
    860              else
    861              {
    862                  /* Disable the selected ADC conversion on external event for injected group and stop the selected
    863                     ADC injected conversion */
    864                  ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
    865              }
    866          }
    867          
    868          /**
    869            * @brief  Gets the selected ADC Software start injected conversion Status.
    870            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    871            * @retval The new state of ADC software start injected conversion (SET or RESET).
    872            */
    873          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef *ADCx)
    874          {
    875              FlagStatus bitstatus = RESET;
    876              /* Check the parameters */
    877              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    878              /* Check the status of JSWSTART bit */
    879              if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
    880              {
    881                  /* JSWSTART bit is set */
    882                  bitstatus = SET;
    883              }
    884              else
    885              {
    886                  /* JSWSTART bit is reset */
    887                  bitstatus = RESET;
    888              }
    889              /* Return the JSWSTART bit status */
    890              return  bitstatus;
    891          }
    892          
    893          /**
    894            * @brief  Configures for the selected ADC injected channel its corresponding
    895            *         rank in the sequencer and its sample time.
    896            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    897            * @param  ADC_Channel: the ADC channel to configure.
    898            *   This parameter can be one of the following values:
    899            *     @arg ADC_Channel_0: ADC Channel0 selected
    900            *     @arg ADC_Channel_1: ADC Channel1 selected
    901            *     @arg ADC_Channel_2: ADC Channel2 selected
    902            *     @arg ADC_Channel_3: ADC Channel3 selected
    903            *     @arg ADC_Channel_4: ADC Channel4 selected
    904            *     @arg ADC_Channel_5: ADC Channel5 selected
    905            *     @arg ADC_Channel_6: ADC Channel6 selected
    906            *     @arg ADC_Channel_7: ADC Channel7 selected
    907            *     @arg ADC_Channel_8: ADC Channel8 selected
    908            *     @arg ADC_Channel_9: ADC Channel9 selected
    909            *     @arg ADC_Channel_10: ADC Channel10 selected
    910            *     @arg ADC_Channel_11: ADC Channel11 selected
    911            *     @arg ADC_Channel_12: ADC Channel12 selected
    912            *     @arg ADC_Channel_13: ADC Channel13 selected
    913            *     @arg ADC_Channel_14: ADC Channel14 selected
    914            *     @arg ADC_Channel_15: ADC Channel15 selected
    915            *     @arg ADC_Channel_16: ADC Channel16 selected
    916            *     @arg ADC_Channel_17: ADC Channel17 selected
    917            * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
    918            * @param  ADC_SampleTime: The sample time value to be set for the selected channel.
    919            *   This parameter can be one of the following values:
    920            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    921            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    922            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    923            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles
    924            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles
    925            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles
    926            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles
    927            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles
    928            * @retval None
    929            */
    930          void ADC_InjectedChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    931          {
    932              uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
    933              /* Check the parameters */
    934              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    935              assert_param(IS_ADC_CHANNEL(ADC_Channel));
    936              assert_param(IS_ADC_INJECTED_RANK(Rank));
    937              assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    938              /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    939              if (ADC_Channel > ADC_Channel_9)
    940              {
    941                  /* Get the old register value */
    942                  tmpreg1 = ADCx->SMPR1;
    943                  /* Calculate the mask to clear */
    944                  tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    945                  /* Clear the old channel sample time */
    946                  tmpreg1 &= ~tmpreg2;
    947                  /* Calculate the mask to set */
    948                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    949                  /* Set the new channel sample time */
    950                  tmpreg1 |= tmpreg2;
    951                  /* Store the new register value */
    952                  ADCx->SMPR1 = tmpreg1;
    953              }
    954              else /* ADC_Channel include in ADC_Channel_[0..9] */
    955              {
    956                  /* Get the old register value */
    957                  tmpreg1 = ADCx->SMPR2;
    958                  /* Calculate the mask to clear */
    959                  tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    960                  /* Clear the old channel sample time */
    961                  tmpreg1 &= ~tmpreg2;
    962                  /* Calculate the mask to set */
    963                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    964                  /* Set the new channel sample time */
    965                  tmpreg1 |= tmpreg2;
    966                  /* Store the new register value */
    967                  ADCx->SMPR2 = tmpreg1;
    968              }
    969              /* Rank configuration */
    970              /* Get the old register value */
    971              tmpreg1 = ADCx->JSQR;
    972              /* Get JL value: Number = JL+1 */
    973              tmpreg3 =  (tmpreg1 & JSQR_JL_Set) >> 20;
    974              /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
    975              tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
    976              /* Clear the old JSQx bits for the selected rank */
    977              tmpreg1 &= ~tmpreg2;
    978              /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
    979              tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
    980              /* Set the JSQx bits for the selected rank */
    981              tmpreg1 |= tmpreg2;
    982              /* Store the new register value */
    983              ADCx->JSQR = tmpreg1;
    984          }
    985          
    986          /**
    987            * @brief  Configures the sequencer length for injected channels
    988            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    989            * @param  Length: The sequencer length.
    990            *   This parameter must be a number between 1 to 4.
    991            * @retval None
    992            */
    993          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef *ADCx, uint8_t Length)
    994          {
    995              uint32_t tmpreg1 = 0;
    996              uint32_t tmpreg2 = 0;
    997              /* Check the parameters */
    998              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    999              assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1000          
   1001              /* Get the old register value */
   1002              tmpreg1 = ADCx->JSQR;
   1003              /* Clear the old injected sequnence lenght JL bits */
   1004              tmpreg1 &= JSQR_JL_Reset;
   1005              /* Set the injected sequnence lenght JL bits */
   1006              tmpreg2 = Length - 1;
   1007              tmpreg1 |= tmpreg2 << 20;
   1008              /* Store the new register value */
   1009              ADCx->JSQR = tmpreg1;
   1010          }
   1011          
   1012          /**
   1013            * @brief  Set the injected channels conversion value offset
   1014            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1015            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset.
   1016            *   This parameter can be one of the following values:
   1017            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1018            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1019            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1020            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1021            * @param  Offset: the offset value for the selected ADC injected channel
   1022            *   This parameter must be a 12bit value.
   1023            * @retval None
   1024            */
   1025          void ADC_SetInjectedOffset(ADC_TypeDef *ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1026          {
   1027              __IO uint32_t tmp = 0;
   1028          
   1029              /* Check the parameters */
   1030              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1031              assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1032              assert_param(IS_ADC_OFFSET(Offset));
   1033          
   1034              tmp = (uint32_t)ADCx;
   1035              tmp += ADC_InjectedChannel;
   1036          
   1037              /* Set the selected injected channel data offset */
   1038              *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1039          }
   1040          
   1041          /**
   1042            * @brief  Returns the ADC injected channel conversion result
   1043            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1044            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1045            *   This parameter can be one of the following values:
   1046            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1047            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1048            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1049            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1050            * @retval The Data conversion value.
   1051            */
   1052          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef *ADCx, uint8_t ADC_InjectedChannel)
   1053          {
   1054              __IO uint32_t tmp = 0;
   1055          
   1056              /* Check the parameters */
   1057              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1058              assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1059          
   1060              tmp = (uint32_t)ADCx;
   1061              tmp += ADC_InjectedChannel + JDR_Offset;
   1062          
   1063              /* Returns the selected injected channel conversion data value */
   1064              return (uint16_t) (*(__IO uint32_t *)  tmp);
   1065          }
   1066          
   1067          /**
   1068            * @brief  Enables or disables the analog watchdog on single/all regular
   1069            *         or injected channels
   1070            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1071            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1072            *   This parameter can be one of the following values:
   1073            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
   1074            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
   1075            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
   1076            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
   1077            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
   1078            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
   1079            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
   1080            * @retval None
   1081            */
   1082          void ADC_AnalogWatchdogCmd(ADC_TypeDef *ADCx, uint32_t ADC_AnalogWatchdog)
   1083          {
   1084              uint32_t tmpreg = 0;
   1085              /* Check the parameters */
   1086              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1087              assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1088              /* Get the old register value */
   1089              tmpreg = ADCx->CR1;
   1090              /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1091              tmpreg &= CR1_AWDMode_Reset;
   1092              /* Set the analog watchdog enable mode */
   1093              tmpreg |= ADC_AnalogWatchdog;
   1094              /* Store the new register value */
   1095              ADCx->CR1 = tmpreg;
   1096          }
   1097          
   1098          /**
   1099            * @brief  Configures the high and low thresholds of the analog watchdog.
   1100            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1101            * @param  HighThreshold: the ADC analog watchdog High threshold value.
   1102            *   This parameter must be a 12bit value.
   1103            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
   1104            *   This parameter must be a 12bit value.
   1105            * @retval None
   1106            */
   1107          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef *ADCx, uint16_t HighThreshold,
   1108                                                  uint16_t LowThreshold)
   1109          {
   1110              /* Check the parameters */
   1111              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1112              assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1113              assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1114              /* Set the ADCx high threshold */
   1115              ADCx->HTR = HighThreshold;
   1116              /* Set the ADCx low threshold */
   1117              ADCx->LTR = LowThreshold;
   1118          }
   1119          
   1120          /**
   1121            * @brief  Configures the analog watchdog guarded single channel
   1122            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1123            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog.
   1124            *   This parameter can be one of the following values:
   1125            *     @arg ADC_Channel_0: ADC Channel0 selected
   1126            *     @arg ADC_Channel_1: ADC Channel1 selected
   1127            *     @arg ADC_Channel_2: ADC Channel2 selected
   1128            *     @arg ADC_Channel_3: ADC Channel3 selected
   1129            *     @arg ADC_Channel_4: ADC Channel4 selected
   1130            *     @arg ADC_Channel_5: ADC Channel5 selected
   1131            *     @arg ADC_Channel_6: ADC Channel6 selected
   1132            *     @arg ADC_Channel_7: ADC Channel7 selected
   1133            *     @arg ADC_Channel_8: ADC Channel8 selected
   1134            *     @arg ADC_Channel_9: ADC Channel9 selected
   1135            *     @arg ADC_Channel_10: ADC Channel10 selected
   1136            *     @arg ADC_Channel_11: ADC Channel11 selected
   1137            *     @arg ADC_Channel_12: ADC Channel12 selected
   1138            *     @arg ADC_Channel_13: ADC Channel13 selected
   1139            *     @arg ADC_Channel_14: ADC Channel14 selected
   1140            *     @arg ADC_Channel_15: ADC Channel15 selected
   1141            *     @arg ADC_Channel_16: ADC Channel16 selected
   1142            *     @arg ADC_Channel_17: ADC Channel17 selected
   1143            * @retval None
   1144            */
   1145          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel)
   1146          {
   1147              uint32_t tmpreg = 0;
   1148              /* Check the parameters */
   1149              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1150              assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1151              /* Get the old register value */
   1152              tmpreg = ADCx->CR1;
   1153              /* Clear the Analog watchdog channel select bits */
   1154              tmpreg &= CR1_AWDCH_Reset;
   1155              /* Set the Analog watchdog channel */
   1156              tmpreg |= ADC_Channel;
   1157              /* Store the new register value */
   1158              ADCx->CR1 = tmpreg;
   1159          }
   1160          
   1161          /**
   1162            * @brief  Enables or disables the temperature sensor and Vrefint channel.
   1163            * @param  NewState: new state of the temperature sensor.
   1164            *   This parameter can be: ENABLE or DISABLE.
   1165            * @retval None
   1166            */
   1167          void ADC_TempSensorVrefintCmd(FunctionalState NewState)
   1168          {
   1169              /* Check the parameters */
   1170              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1171              if (NewState != DISABLE)
   1172              {
   1173                  /* Enable the temperature sensor and Vrefint channel*/
   1174                  ADC1->CR2 |= CR2_TSVREFE_Set;
   1175              }
   1176              else
   1177              {
   1178                  /* Disable the temperature sensor and Vrefint channel*/
   1179                  ADC1->CR2 &= CR2_TSVREFE_Reset;
   1180              }
   1181          }
   1182          
   1183          /**
   1184            * @brief  Checks whether the specified ADC flag is set or not.
   1185            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1186            * @param  ADC_FLAG: specifies the flag to check.
   1187            *   This parameter can be one of the following values:
   1188            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1189            *     @arg ADC_FLAG_EOC: End of conversion flag
   1190            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1191            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1192            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1193            * @retval The new state of ADC_FLAG (SET or RESET).
   1194            */
   1195          FlagStatus ADC_GetFlagStatus(ADC_TypeDef *ADCx, uint8_t ADC_FLAG)
   1196          {
   1197              FlagStatus bitstatus = RESET;
   1198              /* Check the parameters */
   1199              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1200              assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1201              /* Check the status of the specified ADC flag */
   1202              if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1203              {
   1204                  /* ADC_FLAG is set */
   1205                  bitstatus = SET;
   1206              }
   1207              else
   1208              {
   1209                  /* ADC_FLAG is reset */
   1210                  bitstatus = RESET;
   1211              }
   1212              /* Return the ADC_FLAG status */
   1213              return  bitstatus;
   1214          }
   1215          
   1216          /**
   1217            * @brief  Clears the ADCx's pending flags.
   1218            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1219            * @param  ADC_FLAG: specifies the flag to clear.
   1220            *   This parameter can be any combination of the following values:
   1221            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1222            *     @arg ADC_FLAG_EOC: End of conversion flag
   1223            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1224            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1225            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1226            * @retval None
   1227            */
   1228          void ADC_ClearFlag(ADC_TypeDef *ADCx, uint8_t ADC_FLAG)
   1229          {
   1230              /* Check the parameters */
   1231              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1232              assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1233              /* Clear the selected ADC flags */
   1234              ADCx->SR = ~(uint32_t)ADC_FLAG;
   1235          }
   1236          
   1237          /**
   1238            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1239            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1240            * @param  ADC_IT: specifies the ADC interrupt source to check.
   1241            *   This parameter can be one of the following values:
   1242            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1243            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1244            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1245            * @retval The new state of ADC_IT (SET or RESET).
   1246            */
   1247          ITStatus ADC_GetITStatus(ADC_TypeDef *ADCx, uint16_t ADC_IT)
   1248          {
   1249              ITStatus bitstatus = RESET;
   1250              uint32_t itmask = 0, enablestatus = 0;
   1251              /* Check the parameters */
   1252              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1253              assert_param(IS_ADC_GET_IT(ADC_IT));
   1254              /* Get the ADC IT index */
   1255              itmask = ADC_IT >> 8;
   1256              /* Get the ADC_IT enable bit status */
   1257              enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
   1258              /* Check the status of the specified ADC interrupt */
   1259              if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   1260              {
   1261                  /* ADC_IT is set */
   1262                  bitstatus = SET;
   1263              }
   1264              else
   1265              {
   1266                  /* ADC_IT is reset */
   1267                  bitstatus = RESET;
   1268              }
   1269              /* Return the ADC_IT status */
   1270              return  bitstatus;
   1271          }
   1272          
   1273          /**
   1274            * @brief  Clears the ADCx's interrupt pending bits.
   1275            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1276            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1277            *   This parameter can be any combination of the following values:
   1278            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1279            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1280            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1281            * @retval None
   1282            */
   1283          void ADC_ClearITPendingBit(ADC_TypeDef *ADCx, uint16_t ADC_IT)
   1284          {
   1285              uint8_t itmask = 0;
   1286              /* Check the parameters */
   1287              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1288              assert_param(IS_ADC_IT(ADC_IT));
   1289              /* Get the ADC IT index */
   1290              itmask = (uint8_t)(ADC_IT >> 8);
   1291              /* Clear the selected ADC interrupt pending bits */
   1292              ADCx->SR = ~(uint32_t)itmask;
   1293          }
   1294          
   1295          /**
   1296            * @}
   1297            */
   1298          
   1299          /**
   1300            * @}
   1301            */
   1302          
   1303          /**
   1304            * @}
   1305            */
   1306          
   1307          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_AnalogWatchdogCmd
        0  ADC_AnalogWatchdogSingleChannelConfig
        0  ADC_AnalogWatchdogThresholdsConfig
        0  ADC_AutoInjectedConvCmd
        0  ADC_ClearFlag
        0  ADC_ClearITPendingBit
        0  ADC_Cmd
        0  ADC_DMACmd
        8  ADC_DeInit
             8 -> RCC_APB2PeriphResetCmd
        4  ADC_DiscModeChannelCountConfig
        0  ADC_DiscModeCmd
        0  ADC_ExternalTrigConvCmd
        0  ADC_ExternalTrigInjectedConvCmd
        0  ADC_ExternalTrigInjectedConvConfig
        0  ADC_GetCalibrationStatus
        0  ADC_GetConversionValue
        0  ADC_GetDualModeConversionValue
        0  ADC_GetFlagStatus
       12  ADC_GetITStatus
        4  ADC_GetInjectedConversionValue
        0  ADC_GetResetCalibrationStatus
        0  ADC_GetSoftwareStartConvStatus
        0  ADC_GetSoftwareStartInjectedConvCmdStatus
        4  ADC_ITConfig
        8  ADC_Init
       20  ADC_InjectedChannelConfig
        0  ADC_InjectedDiscModeCmd
        4  ADC_InjectedSequencerLengthConfig
       16  ADC_RegularChannelConfig
        0  ADC_ResetCalibration
        4  ADC_SetInjectedOffset
        0  ADC_SoftwareStartConvCmd
        0  ADC_SoftwareStartInjectedConvCmd
        0  ADC_StartCalibration
        0  ADC_StructInit
        0  ADC_TempSensorVrefintCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      16  ADC_AnalogWatchdogCmd
      18  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      16  ADC_ClearITPendingBit
      26  ADC_Cmd
      28  ADC_DMACmd
      94  ADC_DeInit
      30  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_ExternalTrigConvCmd
      26  ADC_ExternalTrigInjectedConvCmd
      16  ADC_ExternalTrigInjectedConvConfig
      24  ADC_GetCalibrationStatus
       6  ADC_GetConversionValue
       6  ADC_GetDualModeConversionValue
      26  ADC_GetFlagStatus
      54  ADC_GetITStatus
      32  ADC_GetInjectedConversionValue
      24  ADC_GetResetCalibrationStatus
      24  ADC_GetSoftwareStartConvStatus
      24  ADC_GetSoftwareStartInjectedConvCmdStatus
      36  ADC_ITConfig
      80  ADC_Init
     178  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      30  ADC_InjectedSequencerLengthConfig
     238  ADC_RegularChannelConfig
      10  ADC_ResetCalibration
      26  ADC_SetInjectedOffset
      26  ADC_SoftwareStartConvCmd
      26  ADC_SoftwareStartInjectedConvCmd
      10  ADC_StartCalibration
      26  ADC_StructInit
      34  ADC_TempSensorVrefintCmd

 
 1 364 bytes in section .text
 
 1 364 bytes of CODE memory

Errors: none
Warnings: none
